/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/@jridgewell/trace-mapping@0.3.22/dist/trace-mapping.umd.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import e from"./sucrase.sourcemap-codec.umd.js";import n from"./sucrase.resolve-uri.umd.js";"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;var o={exports:{}};!function(e,n,o){function t(e,n){return n&&!n.endsWith("/")&&(n+="/"),o(e,n)}function r(e){if(!e)return"";const n=e.lastIndexOf("/");return e.slice(0,n+1)}const s=0,l=1,i=2,c=3,u=4,d=1,a=2;function f(e,n){const o=p(e,0);if(o===e.length)return e;n||(e=e.slice());for(let t=o;t<e.length;t=p(e,t+1))e[t]=h(e[t],n);return e}function p(e,n){for(let o=n;o<e.length;o++)if(!g(e[o]))return o;return e.length}function g(e){for(let n=1;n<e.length;n++)if(e[n][s]<e[n-1][s])return!1;return!0}function h(e,n){return n||(e=e.slice()),e.sort(m)}function m(e,n){return e[s]-n[s]}let M=!1;function _(e,n,o,t){for(;o<=t;){const r=o+(t-o>>1),l=e[r][s]-n;if(0===l)return M=!0,r;l<0?o=r+1:t=r-1}return M=!1,o-1}function v(e,n,o){for(let t=o+1;t<e.length&&e[t][s]===n;o=t++);return o}function x(e,n,o){for(let t=o-1;t>=0&&e[t][s]===n;o=t--);return o}function S(){return{lastKey:-1,lastNeedle:-1,lastIndex:-1}}function y(e,n,o,t){const{lastKey:r,lastNeedle:l,lastIndex:i}=o;let c=0,u=e.length-1;if(t===r){if(n===l)return M=-1!==i&&e[i][s]===n,i;n>=l?c=-1===i?0:i:u=i}return o.lastKey=t,o.lastNeedle=n,o.lastIndex=_(e,n,c,u)}function w(e,n){const o=n.map(E);for(let t=0;t<e.length;t++){const r=e[t];for(let e=0;e<r.length;e++){const u=r[e];if(1===u.length)continue;const d=u[l],a=u[i],f=u[c],p=o[d],g=p[a]||(p[a]=[]),h=n[d],m=v(g,f,y(g,f,h,a));b(g,h.lastIndex=m+1,[f,t,u[s]])}}return o}function b(e,n,o){for(let o=e.length;o>n;o--)e[o]=e[o-1];e[n]=o}function E(){return{__proto__:null}}const O=function(n,o){const t="string"==typeof n?JSON.parse(n):n;if(!("sections"in t))return new L(t,o);const r=[],s=[],l=[],i=[];P(t,o,r,s,l,i,0,0,1/0,1/0);const c={version:3,file:t.file,names:i,sources:s,sourcesContent:l,mappings:r};return e.presortedDecodedMap(c)};function P(e,n,o,t,r,s,l,i,c,u){const{sections:d}=e;for(let e=0;e<d.length;e++){const{map:a,offset:f}=d[e];let p=c,g=u;if(e+1<d.length){const n=d[e+1].offset;p=Math.min(c,l+n.line),p===c?g=Math.min(u,i+n.column):p<c&&(g=i+n.column)}C(a,n,o,t,r,s,l+f.line,i+f.column,p,g)}}function C(n,o,t,r,d,a,f,p,g,h){if("sections"in n)return P(...arguments);const m=new L(n,o),M=r.length,_=a.length,v=e.decodedMappings(m),{resolvedSources:x,sourcesContent:S}=m;if(F(r,x),F(a,m.names),S)F(d,S);else for(let e=0;e<x.length;e++)d.push(null);for(let e=0;e<v.length;e++){const n=f+e;if(n>g)return;const o=R(t,n),r=0===e?p:0,d=v[e];for(let e=0;e<d.length;e++){const t=d[e],a=r+t[s];if(n===g&&a>=h)return;if(1===t.length){o.push([a]);continue}const f=M+t[l],p=t[i],m=t[c];o.push(4===t.length?[a,f,p,m]:[a,f,p,m,_+t[u]])}}}function F(e,n){for(let o=0;o<n.length;o++)e.push(n[o])}function R(e,n){for(let o=e.length;o<=n;o++)e[o]=[];return e[n]}const T="`line` must be greater than 0 (lines start at line 1)",N="`column` must be greater than or equal to 0 (columns start at column 0)",D=-1,A=1;e.encodedMappings=void 0,e.decodedMappings=void 0,e.traceSegment=void 0,e.originalPositionFor=void 0,e.generatedPositionFor=void 0,e.allGeneratedPositionsFor=void 0,e.eachMapping=void 0,e.sourceContentFor=void 0,e.presortedDecodedMap=void 0,e.decodedMap=void 0,e.encodedMap=void 0;class L{constructor(e,n){const o="string"==typeof e;if(!o&&e._decodedMemo)return e;const s=o?JSON.parse(e):e,{version:l,file:i,names:c,sourceRoot:u,sources:d,sourcesContent:a}=s;this.version=l,this.file=i,this.names=c||[],this.sourceRoot=u,this.sources=d,this.sourcesContent=a;const p=t(u||"",r(n));this.resolvedSources=d.map((e=>t(e||"",p)));const{mappings:g}=s;"string"==typeof g?(this._encoded=g,this._decoded=void 0):(this._encoded=void 0,this._decoded=f(g,o)),this._decodedMemo=S(),this._bySources=void 0,this._bySourceMemos=void 0}}function U(e,n){return{version:e.version,file:e.file,names:e.names,sourceRoot:e.sourceRoot,sources:e.sources,sourcesContent:e.sourcesContent,mappings:n}}function G(e,n,o,t){return{source:e,line:n,column:o,name:t}}function I(e,n){return{line:e,column:n}}function B(e,n,o,t,r){let s=y(e,t,n,o);return M?s=(r===D?v:x)(e,t,s):r===D&&s++,-1===s||s===e.length?-1:s}function K(e,n,o,t,r){let l=B(e,n,o,t,A);if(M||r!==D||l++,-1===l||l===e.length)return[];const i=M?t:e[l][s];M||(l=x(e,i,l));const c=v(e,i,l),u=[];for(;l<=c;l++){const n=e[l];u.push(I(n[d]+1,n[a]))}return u}(()=>{function o(n,o,t,r,s,l){if(--t<0)throw new Error(T);if(r<0)throw new Error(N);const{sources:i,resolvedSources:c}=n;let u=i.indexOf(o);if(-1===u&&(u=c.indexOf(o)),-1===u)return l?[]:I(null,null);const f=(n._bySources||(n._bySources=w(e.decodedMappings(n),n._bySourceMemos=i.map(S))))[u][t];if(null==f)return l?[]:I(null,null);const p=n._bySourceMemos[u];if(l)return K(f,p,t,r,s);const g=B(f,p,t,r,s);if(-1===g)return I(null,null);const h=f[g];return I(h[d]+1,h[a])}e.encodedMappings=e=>{var o;return null!==(o=e._encoded)&&void 0!==o?o:e._encoded=n.encode(e._decoded)},e.decodedMappings=e=>e._decoded||(e._decoded=n.decode(e._encoded)),e.traceSegment=(n,o,t)=>{const r=e.decodedMappings(n);if(o>=r.length)return null;const s=r[o],l=B(s,n._decodedMemo,o,t,A);return-1===l?null:s[l]},e.originalPositionFor=(n,{line:o,column:t,bias:r})=>{if(--o<0)throw new Error(T);if(t<0)throw new Error(N);const s=e.decodedMappings(n);if(o>=s.length)return G(null,null,null,null);const d=s[o],a=B(d,n._decodedMemo,o,t,r||A);if(-1===a)return G(null,null,null,null);const f=d[a];if(1===f.length)return G(null,null,null,null);const{names:p,resolvedSources:g}=n;return G(g[f[l]],f[i]+1,f[c],5===f.length?p[f[u]]:null)},e.allGeneratedPositionsFor=(e,{source:n,line:t,column:r,bias:s})=>o(e,n,t,r,s||D,!0),e.generatedPositionFor=(e,{source:n,line:t,column:r,bias:s})=>o(e,n,t,r,s||A,!1),e.eachMapping=(n,o)=>{const t=e.decodedMappings(n),{names:r,resolvedSources:s}=n;for(let e=0;e<t.length;e++){const n=t[e];for(let t=0;t<n.length;t++){const l=n[t],i=e+1,c=l[0];let u=null,d=null,a=null,f=null;1!==l.length&&(u=s[l[1]],d=l[2]+1,a=l[3]),5===l.length&&(f=r[l[4]]),o({generatedLine:i,generatedColumn:c,source:u,originalLine:d,originalColumn:a,name:f})}}},e.sourceContentFor=(e,n)=>{const{sources:o,resolvedSources:t,sourcesContent:r}=e;if(null==r)return null;let s=o.indexOf(n);return-1===s&&(s=t.indexOf(n)),-1===s?null:r[s]},e.presortedDecodedMap=(e,n)=>{const o=new L(U(e,[]),n);return o._decoded=e.mappings,o},e.decodedMap=n=>U(n,e.decodedMappings(n)),e.encodedMap=n=>U(n,e.encodedMappings(n))})(),e.AnyMap=O,e.GREATEST_LOWER_BOUND=A,e.LEAST_UPPER_BOUND=D,e.TraceMap=L}(o.exports,e,n);var t=o.exports,r=o.exports.AnyMap,s=o.exports.GREATEST_LOWER_BOUND,l=o.exports.LEAST_UPPER_BOUND,i=o.exports.TraceMap,c=o.exports.allGeneratedPositionsFor,u=o.exports.decodedMap,d=o.exports.decodedMappings,a=o.exports.eachMapping,f=o.exports.encodedMap,p=o.exports.encodedMappings,g=o.exports.generatedPositionFor,h=o.exports.originalPositionFor,m=o.exports.presortedDecodedMap,M=o.exports.sourceContentFor,_=o.exports.traceSegment;export{r as AnyMap,s as GREATEST_LOWER_BOUND,l as LEAST_UPPER_BOUND,i as TraceMap,c as allGeneratedPositionsFor,u as decodedMap,d as decodedMappings,t as default,a as eachMapping,f as encodedMap,p as encodedMappings,g as generatedPositionFor,h as originalPositionFor,m as presortedDecodedMap,M as sourceContentFor,_ as traceSegment};
//# sourceMappingURL=/sm/508b8d800d4bf83129e5295a52dd113cf37bbf2f16f2da932650323b6cc1f62f.map